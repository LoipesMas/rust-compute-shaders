#version 440 
layout(local_size_x = 1) in;

struct CellData{
    vec2 position;
    vec2 velocity;
};

uniform int u_count;
uniform float u_dt;
uniform float u_time;

layout(shared, binding = 0) writeonly buffer OutputData
{
    CellData next[];
};

layout(shared, binding = 1) readonly buffer InputData
{
    CellData input_data[];
};

float cross(vec2 a, vec2 b) {
	return a.x * b.y - a.y * b.x;
}

float angle(vec2 a, vec2 b){
	return atan(cross(a,b), dot(a,b));
}

void main() {

    CellData curr = input_data[gl_GlobalInvocationID.x];
    

    CellData new_cell;
    new_cell = curr;

	float rotation = atan(new_cell.velocity.y, new_cell.velocity.x);
	vec2 norm_vel = normalize(new_cell.velocity);

	float speed = length(new_cell.velocity);

	for (int i = 0; i < u_count; i++){
		if (gl_GlobalInvocationID.x == i)
			continue;

		CellData boid = input_data[i];
		vec2 dir = boid.position-new_cell.position;

		float dist = length(dir);
		if (dist > 0.1)
			continue;
		
		float dir_rot = atan(dir.y, dir.x);
		float rot_diff = angle(norm_vel, normalize(dir));
		//rot_diff = clamp(rot_diff, -1.0, 1.0);
		if (dist < 0.03) {
			rot_diff *= -20.0 * (1.0 + (0.03-dist)/0.03);
			//if (dist < 0.02)
			//	new_cell.position -= normalize(dir) * (0.02 - dist);
		}
		rotation += rot_diff * 0.1 * u_dt;
		rotation = mix(rotation, atan(boid.velocity.y, boid.velocity.x), u_dt);
		new_cell.velocity = vec2(cos(rotation)*speed, sin(rotation)*speed);
		norm_vel = normalize(new_cell.velocity);
	}



    new_cell.position += new_cell.velocity * u_dt;
	new_cell.position = fract(new_cell.position);

    next[gl_GlobalInvocationID.x] = new_cell;
}
